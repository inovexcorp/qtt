package com.inovexcorp.queryservice.routebuilder.cache;

import com.inovexcorp.queryservice.cache.CacheKey;
import com.inovexcorp.queryservice.cache.CacheService;
import com.inovexcorp.queryservice.persistence.CamelRouteTemplate;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;

import java.util.Optional;

/**
 * Camel processor that checks the cache for a previously cached result
 * before executing the expensive Anzo query.
 * <p>
 * This processor is inserted after the Freemarker template processing
 * (which generates the SPARQL query) and before the Anzo producer.
 */
@Slf4j
@RequiredArgsConstructor
public class CacheCheckProcessor implements Processor {

    public static final String CACHE_HIT_PROPERTY = "cacheHit";
    public static final String CACHE_KEY_PROPERTY = "cacheKey";
    public static final String CACHE_CHECK_START_TIME = "cacheCheckStartTime";

    private final CacheService cacheService;
    private final CamelRouteTemplate routeTemplate;
    private final String cacheKeyPrefix;
    private final String layerUris;

    @Override
    public void process(Exchange exchange) throws Exception {
        long startTime = System.currentTimeMillis();
        exchange.setProperty(CACHE_CHECK_START_TIME, startTime);

        // Check if caching is enabled for this route
        if (routeTemplate.getCacheEnabled() == null || !routeTemplate.getCacheEnabled()) {
            log.trace("Cache disabled for route: {}", routeTemplate.getRouteId());
            exchange.setProperty(CACHE_HIT_PROPERTY, false);
            return;
        }

        // Check if cache service is available
        if (!cacheService.isAvailable()) {
            log.debug("Cache service not available for route: {}", routeTemplate.getRouteId());
            exchange.setProperty(CACHE_HIT_PROPERTY, false);
            return;
        }

        try {
            // Get the SPARQL query from the exchange body (generated by Freemarker)
            String sparqlQuery = exchange.getIn().getBody(String.class);

            // Build cache key
            CacheKey cacheKey = CacheKey.builder()
                    .prefix(cacheKeyPrefix)
                    .routeId(routeTemplate.getRouteId())
                    .query(sparqlQuery)
                    .graphmartUri(routeTemplate.getGraphMartUri())
                    .layerUris(layerUris != null ? layerUris : "")
                    .build();

            String key = cacheKey.generate();
            exchange.setProperty(CACHE_KEY_PROPERTY, key);

            // Check cache
            Optional<String> cachedResult = cacheService.get(key);

            if (cachedResult.isPresent()) {
                // Cache hit! Set the cached result as the exchange body
                exchange.getIn().setBody(cachedResult.get());
                exchange.setProperty(CACHE_HIT_PROPERTY, true);

                long duration = System.currentTimeMillis() - startTime;
                log.info("Cache HIT for route '{}' ({}ms)", routeTemplate.getRouteId(), duration);

                // Set a flag to skip the Anzo producer and RDF jsonifier
                exchange.setProperty(Exchange.ROUTE_STOP, true);
            } else {
                // Cache miss - continue to Anzo
                exchange.setProperty(CACHE_HIT_PROPERTY, false);
                long duration = System.currentTimeMillis() - startTime;
                log.debug("Cache MISS for route '{}' ({}ms)", routeTemplate.getRouteId(), duration);
            }
        } catch (Exception e) {
            log.error("Error checking cache for route '{}': {}", routeTemplate.getRouteId(), e.getMessage(), e);
            exchange.setProperty(CACHE_HIT_PROPERTY, false);
            // Continue processing (fail-open behavior)
        }
    }
}
